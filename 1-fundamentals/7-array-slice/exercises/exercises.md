1-Create a fixed-size collection to store integer numeric values ​​and display its initial contents in the output.

2-Create another collection of the same type, but storing text, and assign a value only to the first position.

3-Create a collection initialized at the time of declaration, containing exactly three numeric values.

4-Create a new text collection populated with three values, and display all the elements.

5-Create a numeric collection with automatic size filling, without explicitly specifying the number of elements.

6-Create two different collections, each initialized differently. Display the contents of both to observe the differences between slices and arrays.

7-Create a dynamic collection that stores integers and initialize it with some values.

8-Create a dynamic collection, initialize it with some values, add a new value to this dynamic collection, and display the result.

9-Create a collection of text elements, and then create a second collection that contains only a selection of text elements from the first, limiting the range to two positions.

10-Create a collection of elements, and then a clipping of that collection. Modify an element in the original collection and view the clipping again to see how the change affects the shared elements.

11-Create a new collection based on another, but ensure that changes to the original do not modify the new one.

12-Create a function that receives a dynamic collection of numbers and displays all of their values.

13-Create a function that receives a fixed collection and returns a dynamic version with the same values.

14-Create a function that receives a dynamic collection and returns a new collection containing only a portion of the original elements.

15-Implement logic that adds multiple values ​​to a dynamic collection at runtime.

16-Create a function that receives a dynamic collection and adds new elements while printing the size and capacity with each insertion.

17-Demonstrate, through a clipping exercise, that slices share the same memory area as the underlying array.

18-Create an example that shows that when a slice is enlarged beyond its capacity, Go creates a new internal array, causing the resized slice to no longer share memory with the original slice.