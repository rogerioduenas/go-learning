1-Create a dynamic sequence of integers with a defined initial size and a capacity greater than that size.

2-Create a dynamic sequence and display its current values, along with its size and capacity.

3-Create a dynamic sequence and add a new element to it. Then, display the updated content, size, and capacity.

4-Create a dynamic sequence with a defined initial capacity. Continue adding elements until you exceed that capacity and observe how the capacity is automatically adjusted.

5-Create a dynamic sequence by explicitly setting the same value for size and capacity. Display its properties to compare its behavior with other sequences.

6-Create a function that receives a dy
namic sequence and returns its current size and capacity.

7-Create a routine that fills a sequence until it reaches its initial maximum capacity, and then try adding more elements to observe the internal reallocation.

8-Implement a function that receives a sequence, inserts elements progressively, and displays how the capacity increases non-linearly with each insertion.

9-Create a sequence from another existing sequence and modify elements in the original sequence to analyze whether both share the same internal array.

10-Create a newly initialized sequence and dynamically change its size and capacity, displaying the resulting behavior.

11-Write a function that takes a list and returns a copy of the list, ensuring that the new list uses an internal array independent of the original.

12-Develop an experiment that clearly demonstrates the difference between copying elements of a sequence and simply referencing the same internal array.

13-Create a function that receives a sequence and returns another sequence with manually expanded capacity, ensuring that it does not use the same memory area as the original.

14-Implement a code snippet that monitors and displays the capacity of a sequence before and after each expansion to visualize the runtime's reallocation strategy.

15-Create a simulator that adds elements to a sequence, displaying size and capacity at each iteration. The program should predict the next capacity expansion and stop the process if that expansion exceeds a defined maximum limit.
